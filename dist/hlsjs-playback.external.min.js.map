{"version":3,"file":"hlsjs-playback.external.min.js","sources":["../src/hls.js"],"sourcesContent":["// Copyright 2014 Globo.com Player authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\nimport { Events, HTML5Video, Log, Playback, PlayerError, Utils } from '@clappr/core'\nimport HLSJS from 'hls.js'\n\nconst { now, assign, listContainsIgnoreCase } = Utils\n\nconst AUTO = -1\n\nEvents.register('PLAYBACK_FRAGMENT_CHANGED')\nEvents.register('PLAYBACK_FRAGMENT_PARSING_METADATA')\n\nexport default class HlsjsPlayback extends HTML5Video {\n  get name() { return 'hls' }\n\n  get supportedVersion() { return { min: CLAPPR_CORE_VERSION } }\n\n  get levels() { return this._levels || [] }\n\n  get currentLevel() {\n    if (this._currentLevel === null || this._currentLevel === undefined)\n      return AUTO\n    else\n      return this._currentLevel //0 is a valid level ID\n\n  }\n\n  get isReady() {\n    return this._isReadyState\n  }\n\n  set currentLevel(id) {\n    this._currentLevel = id\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH_START)\n    if (this.options.playback.hlsUseNextLevel)\n      this._hls.nextLevel = this._currentLevel\n    else\n      this._hls.currentLevel = this._currentLevel\n  }\n\n  get _startTime() {\n    if (this._playbackType === Playback.LIVE && this._playlistType !== 'EVENT')\n      return this._extrapolatedStartTime\n\n    return this._playableRegionStartTime\n  }\n\n  get _now() {\n    return now()\n  }\n\n  // the time in the video element which should represent the start of the sliding window\n  // extrapolated to increase in real time (instead of jumping as the early segments are removed)\n  get _extrapolatedStartTime() {\n    if (!this._localStartTimeCorrelation)\n      return this._playableRegionStartTime\n\n    let corr = this._localStartTimeCorrelation\n    let timePassed = this._now - corr.local\n    let extrapolatedWindowStartTime = (corr.remote + timePassed) / 1000\n    // cap at the end of the extrapolated window duration\n    return Math.min(extrapolatedWindowStartTime, this._playableRegionStartTime + this._extrapolatedWindowDuration)\n  }\n\n  // the time in the video element which should represent the end of the content\n  // extrapolated to increase in real time (instead of jumping as segments are added)\n  get _extrapolatedEndTime() {\n    let actualEndTime = this._playableRegionStartTime + this._playableRegionDuration\n    if (!this._localEndTimeCorrelation)\n      return actualEndTime\n\n    let corr = this._localEndTimeCorrelation\n    let timePassed = this._now - corr.local\n    let extrapolatedEndTime = (corr.remote + timePassed) / 1000\n    return Math.max(actualEndTime - this._extrapolatedWindowDuration, Math.min(extrapolatedEndTime, actualEndTime))\n  }\n\n  get _duration() {\n    return this._extrapolatedEndTime - this._startTime\n  }\n\n  // Returns the duration (seconds) of the window that the extrapolated start time is allowed\n  // to move in before being capped.\n  // The extrapolated start time should never reach the cap at the end of the window as the\n  // window should slide as chunks are removed from the start.\n  // This also applies to the extrapolated end time in the same way.\n  //\n  // If chunks aren't being removed for some reason that the start time will reach and remain fixed at\n  // playableRegionStartTime + extrapolatedWindowDuration\n  //\n  //                                <-- window duration -->\n  // I.e   playableRegionStartTime |-----------------------|\n  //                               | -->   .       .       .\n  //                               .   --> | -->   .       .\n  //                               .       .   --> | -->   .\n  //                               .       .       .   --> |\n  //                               .       .       .       .\n  //                                 extrapolatedStartTime\n  get _extrapolatedWindowDuration() {\n    if (this._segmentTargetDuration === null)\n      return 0\n\n    return this._extrapolatedWindowNumSegments * this._segmentTargetDuration\n  }\n\n  get bandwidthEstimate() {\n    return this._hls && this._hls.bandwidthEstimate\n  }\n\n  static get HLSJS() {\n    return HLSJS\n  }\n\n  constructor(...args) {\n    super(...args)\n    // backwards compatibility (TODO: remove on 0.3.0)\n    this.options.playback = { ...this.options, ...this.options.playback }\n    this._minDvrSize = typeof (this.options.hlsMinimumDvrSize) === 'undefined' ? 60 : this.options.hlsMinimumDvrSize\n    // The size of the start time extrapolation window measured as a multiple of segments.\n    // Should be 2 or higher, or 0 to disable. Should only need to be increased above 2 if more than one segment is\n    // removed from the start of the playlist at a time. E.g if the playlist is cached for 10 seconds and new chunks are\n    // added/removed every 5.\n    this._extrapolatedWindowNumSegments = !this.options.playback || typeof (this.options.playback.extrapolatedWindowNumSegments) === 'undefined' ? 2 :  this.options.playback.extrapolatedWindowNumSegments\n\n    this._playbackType = Playback.VOD\n    this._lastTimeUpdate = { current: 0, total: 0 }\n    this._lastDuration = null\n    // for hls streams which have dvr with a sliding window,\n    // the content at the start of the playlist is removed as new\n    // content is appended at the end.\n    // this means the actual playable start time will increase as the\n    // start content is deleted\n    // For streams with dvr where the entire recording is kept from the\n    // beginning this should stay as 0\n    this._playableRegionStartTime = 0\n    // {local, remote} remote is the time in the video element that should represent 0\n    //                 local is the system time when the 'remote' measurment took place\n    this._localStartTimeCorrelation = null\n    // {local, remote} remote is the time in the video element that should represents the end\n    //                 local is the system time when the 'remote' measurment took place\n    this._localEndTimeCorrelation = null\n    // if content is removed from the beginning then this empty area should\n    // be ignored. \"playableRegionDuration\" excludes the empty area\n    this._playableRegionDuration = 0\n    // #EXT-X-PROGRAM-DATE-TIME\n    this._programDateTime = 0\n    // true when the actual duration is longer than hlsjs's live sync point\n    // when this is false playableRegionDuration will be the actual duration\n    // when this is true playableRegionDuration will exclude the time after the sync point\n    this._durationExcludesAfterLiveSyncPoint = false\n    // #EXT-X-TARGETDURATION\n    this._segmentTargetDuration = null\n    // #EXT-X-PLAYLIST-TYPE\n    this._playlistType = null\n    this._recoverAttemptsRemaining = this.options.hlsRecoverAttempts || 16\n  }\n\n  _setup() {\n    this._ccIsSetup = false\n    this._ccTracksUpdated = false\n    this._hls = new HLSJS(assign({}, this.options.playback.hlsjsConfig))\n    this._hls.once(HLSJS.Events.MEDIA_ATTACHED, () => this._hls.loadSource(this.options.src))\n    this._hls.on(HLSJS.Events.LEVEL_LOADED, (evt, data) => this._updatePlaybackType(evt, data))\n    this._hls.on(HLSJS.Events.LEVEL_UPDATED, (evt, data) => this._onLevelUpdated(evt, data))\n    this._hls.on(HLSJS.Events.LEVEL_SWITCHING, (evt,data) => this._onLevelSwitch(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_CHANGED, (evt, data) => this._onFragmentChanged(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_LOADED, (evt, data) => this._onFragmentLoaded(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_PARSING_METADATA, (evt, data) => this._onFragmentParsingMetadata(evt, data))\n    this._hls.on(HLSJS.Events.ERROR, (evt, data) => this._onHLSJSError(evt, data))\n    this._hls.on(HLSJS.Events.SUBTITLE_TRACK_LOADED, (evt, data) => this._onSubtitleLoaded(evt, data))\n    this._hls.on(HLSJS.Events.SUBTITLE_TRACKS_UPDATED, () => this._ccTracksUpdated = true)\n    this._hls.attachMedia(this.el)\n  }\n\n  _onFragmentParsingMetadata(evt, data) {\n    this.trigger(Events.Custom.PLAYBACK_FRAGMENT_PARSING_METADATA, { evt, data })\n  }\n\n  render() {\n    this._ready()\n    return super.render()\n  }\n\n  _ready() {\n    this._isReadyState = true\n    this.trigger(Events.PLAYBACK_READY, this.name)\n  }\n\n  _recover(evt, data, error) {\n    if (!this._recoveredDecodingError) {\n      this._recoveredDecodingError = true\n      this._hls.recoverMediaError()\n    } else if (!this._recoveredAudioCodecError) {\n      this._recoveredAudioCodecError = true\n      this._hls.swapAudioCodec()\n      this._hls.recoverMediaError()\n    } else {\n      Log.error('hlsjs: failed to recover', { evt, data })\n      error.level = PlayerError.Levels.FATAL\n      const formattedError = this.createError(error)\n      this.trigger(Events.PLAYBACK_ERROR, formattedError)\n      this.stop()\n    }\n  }\n\n  // override\n  _setupSrc(srcUrl) { // eslint-disable-line no-unused-vars\n    // this playback manages the src on the video element itself\n  }\n\n  _startTimeUpdateTimer() {\n    if (this._timeUpdateTimer) return\n\n    this._timeUpdateTimer = setInterval(() => {\n      this._onDurationChange()\n      this._onTimeUpdate()\n    }, 100)\n  }\n\n  _stopTimeUpdateTimer() {\n    if (!this._timeUpdateTimer) return\n\n    clearInterval(this._timeUpdateTimer)\n    this._timeUpdateTimer = null\n  }\n\n  getProgramDateTime() {\n    return this._programDateTime\n  }\n  // the duration on the video element itself should not be used\n  // as this does not necesarily represent the duration of the stream\n  // https://github.com/clappr/clappr/issues/668#issuecomment-157036678\n  getDuration() {\n    return this._duration\n  }\n\n  getCurrentTime() {\n    // e.g. can be < 0 if user pauses near the start\n    // eventually they will then be kicked to the end by hlsjs if they run out of buffer\n    // before the official start time\n    return Math.max(0, this.el.currentTime - this._startTime)\n  }\n\n  // the time that \"0\" now represents relative to when playback started\n  // for a stream with a sliding window this will increase as content is\n  // removed from the beginning\n  getStartTimeOffset() {\n    return this._startTime\n  }\n\n  seekPercentage(percentage) {\n    let seekTo = this._duration\n    if (percentage > 0)\n      seekTo = this._duration * (percentage / 100)\n\n    this.seek(seekTo)\n  }\n\n  seek(time) {\n    if (time < 0) {\n      Log.warn('Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point.')\n      time = this.getDuration()\n    }\n    // assume live if time within 3 seconds of end of stream\n    this.dvrEnabled && this._updateDvr(time < this.getDuration()-3)\n    time += this._startTime\n    this.el.currentTime = time\n  }\n\n  seekToLivePoint() {\n    this.seek(this.getDuration())\n  }\n\n  _updateDvr(status) {\n    this.trigger(Events.PLAYBACK_DVR, status)\n    this.trigger(Events.PLAYBACK_STATS_ADD, { 'dvr': status })\n  }\n\n  _updateSettings() {\n    if (this._playbackType === Playback.VOD)\n      this.settings.left = ['playpause', 'position', 'duration']\n    else if (this.dvrEnabled)\n      this.settings.left = ['playpause']\n    else\n      this.settings.left = ['playstop']\n\n    this.settings.seekEnabled = this.isSeekEnabled()\n    this.trigger(Events.PLAYBACK_SETTINGSUPDATE)\n  }\n\n  _onHLSJSError(evt, data) {\n    const error = {\n      code: `${data.type}_${data.details}`,\n      description: `${this.name} error: type: ${data.type}, details: ${data.details}`,\n      raw: data,\n    }\n    let formattedError\n    if (data.response) error.description += `, response: ${JSON.stringify(data.response)}`\n    // only report/handle errors if they are fatal\n    // hlsjs should automatically handle non fatal errors\n    if (data.fatal) {\n      if (this._recoverAttemptsRemaining > 0) {\n        this._recoverAttemptsRemaining -= 1\n        switch (data.type) {\n        case HLSJS.ErrorTypes.NETWORK_ERROR:\n          switch (data.details) {\n          // The following network errors cannot be recovered with HLS.startLoad()\n          // For more details, see https://github.com/video-dev/hls.js/blob/master/doc/design.md#error-detection-and-handling\n          // For \"level load\" fatal errors, see https://github.com/video-dev/hls.js/issues/1138\n          case HLSJS.ErrorDetails.MANIFEST_LOAD_ERROR:\n          case HLSJS.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n          case HLSJS.ErrorDetails.MANIFEST_PARSING_ERROR:\n          case HLSJS.ErrorDetails.LEVEL_LOAD_ERROR:\n          case HLSJS.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            Log.error('hlsjs: unrecoverable network fatal error.', { evt, data })\n            formattedError = this.createError(error)\n            this.trigger(Events.PLAYBACK_ERROR, formattedError)\n            this.stop()\n            break\n          default:\n            Log.warn('hlsjs: trying to recover from network error.', { evt, data })\n            error.level = PlayerError.Levels.WARN\n            this._hls.startLoad()\n            break\n          }\n          break\n        case HLSJS.ErrorTypes.MEDIA_ERROR:\n          Log.warn('hlsjs: trying to recover from media error.', { evt, data })\n          error.level = PlayerError.Levels.WARN\n          this._recover(evt, data, error)\n          break\n        default:\n          Log.error('hlsjs: could not recover from error.', { evt, data })\n          formattedError = this.createError(error)\n          this.trigger(Events.PLAYBACK_ERROR, formattedError)\n          this.stop()\n          break\n        }\n      } else {\n        Log.error('hlsjs: could not recover from error after maximum number of attempts.', { evt, data })\n        formattedError = this.createError(error)\n        this.trigger(Events.PLAYBACK_ERROR, formattedError)\n        this.stop()\n      }\n    } else {\n      // Transforms HLSJS.ErrorDetails.KEY_LOAD_ERROR non-fatal error to\n      // playback fatal error if triggerFatalErrorOnResourceDenied playback\n      // option is set. HLSJS.ErrorTypes.KEY_SYSTEM_ERROR are fatal errors\n      // and therefore already handled.\n      if (this.options.playback.triggerFatalErrorOnResourceDenied && this._keyIsDenied(data)) {\n        Log.error('hlsjs: could not load decrypt key.', { evt, data })\n        formattedError = this.createError(error)\n        this.trigger(Events.PLAYBACK_ERROR, formattedError)\n        this.stop()\n        return\n      }\n\n      error.level = PlayerError.Levels.WARN\n      Log.warn('hlsjs: non-fatal error occurred', { evt, data })\n    }\n  }\n\n  _keyIsDenied(data) {\n    return data.type === HLSJS.ErrorTypes.NETWORK_ERROR\n      && data.details === HLSJS.ErrorDetails.KEY_LOAD_ERROR\n      && data.response\n      && data.response.code >= 400\n  }\n\n  _onTimeUpdate() {\n    let update = { current: this.getCurrentTime(), total: this.getDuration(), firstFragDateTime: this.getProgramDateTime() }\n    let isSame = this._lastTimeUpdate && (\n      update.current === this._lastTimeUpdate.current &&\n      update.total === this._lastTimeUpdate.total)\n    if (isSame)\n      return\n\n    this._lastTimeUpdate = update\n    this.trigger(Events.PLAYBACK_TIMEUPDATE, update, this.name)\n  }\n\n  _onDurationChange() {\n    let duration = this.getDuration()\n    if (this._lastDuration === duration)\n      return\n\n    this._lastDuration = duration\n    super._onDurationChange()\n  }\n\n  _onProgress() {\n    if (!this.el.buffered.length)\n      return\n\n    let buffered = []\n    let bufferedPos = 0\n    for (let i = 0; i < this.el.buffered.length; i++) {\n      buffered = [...buffered, {\n        // for a stream with sliding window dvr something that is buffered my slide off the start of the timeline\n        start: Math.max(0, this.el.buffered.start(i) - this._playableRegionStartTime),\n        end: Math.max(0, this.el.buffered.end(i) - this._playableRegionStartTime)\n      }]\n      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end)\n        bufferedPos = i\n\n    }\n    const progress = {\n      start: buffered[bufferedPos].start,\n      current: buffered[bufferedPos].end,\n      total: this.getDuration()\n    }\n    this.trigger(Events.PLAYBACK_PROGRESS, progress, buffered)\n  }\n\n  play() {\n    if (!this._hls)\n      this._setup()\n\n    super.play()\n    this._startTimeUpdateTimer()\n  }\n\n  pause() {\n    if (!this._hls) return\n    this.el.pause()\n    if (this.dvrEnabled) this._updateDvr(true)\n  }\n\n  stop() {\n    this._stopTimeUpdateTimer()\n    if (this._hls) {\n      super.stop()\n      this._hls.destroy()\n      delete this._hls\n    }\n  }\n\n  destroy() {\n    this._stopTimeUpdateTimer()\n    if (this._hls) {\n      this._hls.destroy()\n      delete this._hls\n    }\n    super.destroy()\n  }\n\n  _updatePlaybackType(evt, data) {\n    this._playbackType = data.details.live ? Playback.LIVE : Playback.VOD\n    this._onLevelUpdated(evt, data)\n\n    // Live stream subtitle tracks detection hack (may not immediately available)\n    if (this._ccTracksUpdated && this._playbackType === Playback.LIVE && this.hasClosedCaptionsTracks)\n      this._onSubtitleLoaded()\n\n  }\n\n  _fillLevels() {\n    this._levels = this._hls.levels.map((level, index) => {\n      return { id: index, level: level, label: `${level.bitrate/1000}Kbps` }\n    })\n    this.trigger(Events.PLAYBACK_LEVELS_AVAILABLE, this._levels)\n  }\n\n  _onLevelUpdated(evt, data) {\n    this._segmentTargetDuration = data.details.targetduration\n    this._playlistType = data.details.type || null\n\n    let startTimeChanged = false\n    let durationChanged = false\n    let fragments = data.details.fragments\n    let previousPlayableRegionStartTime = this._playableRegionStartTime\n    let previousPlayableRegionDuration = this._playableRegionDuration\n\n    if (fragments.length === 0)\n      return\n\n\n    // #EXT-X-PROGRAM-DATE-TIME\n    if (fragments[0].rawProgramDateTime)\n      this._programDateTime = fragments[0].rawProgramDateTime\n\n\n    if (this._playableRegionStartTime !== fragments[0].start) {\n      startTimeChanged = true\n      this._playableRegionStartTime = fragments[0].start\n    }\n\n    if (startTimeChanged) {\n      if (!this._localStartTimeCorrelation) {\n        // set the correlation to map to middle of the extrapolation window\n        this._localStartTimeCorrelation = {\n          local: this._now,\n          remote: (fragments[0].start + (this._extrapolatedWindowDuration/2)) * 1000\n        }\n      } else {\n        // check if the correlation still works\n        let corr = this._localStartTimeCorrelation\n        let timePassed = this._now - corr.local\n        // this should point to a time within the extrapolation window\n        let startTime = (corr.remote + timePassed) / 1000\n        if (startTime < fragments[0].start) {\n          // our start time is now earlier than the first chunk\n          // (maybe the chunk was removed early)\n          // reset correlation so that it sits at the beginning of the first available chunk\n          this._localStartTimeCorrelation = {\n            local: this._now,\n            remote: fragments[0].start * 1000\n          }\n        } else if (startTime > previousPlayableRegionStartTime + this._extrapolatedWindowDuration) {\n          // start time was past the end of the old extrapolation window (so would have been capped)\n          // see if now that time would be inside the window, and if it would be set the correlation\n          // so that it resumes from the time it was at at the end of the old window\n          // update the correlation so that the time starts counting again from the value it's on now\n          this._localStartTimeCorrelation = {\n            local: this._now,\n            remote: Math.max(fragments[0].start, previousPlayableRegionStartTime + this._extrapolatedWindowDuration) * 1000\n          }\n        }\n      }\n    }\n\n    let newDuration = data.details.totalduration\n    // if it's a live stream then shorten the duration to remove access\n    // to the area after hlsjs's live sync point\n    // seeks to areas after this point sometimes have issues\n    if (this._playbackType === Playback.LIVE) {\n      let fragmentTargetDuration = data.details.targetduration\n      let hlsjsConfig = this.options.playback.hlsjsConfig || {}\n      let liveSyncDurationCount = hlsjsConfig.liveSyncDurationCount || HLSJS.DefaultConfig.liveSyncDurationCount\n      let hiddenAreaDuration = fragmentTargetDuration * liveSyncDurationCount\n      if (hiddenAreaDuration <= newDuration) {\n        newDuration -= hiddenAreaDuration\n        this._durationExcludesAfterLiveSyncPoint = true\n      } else { this._durationExcludesAfterLiveSyncPoint = false }\n\n    }\n\n    if (newDuration !== this._playableRegionDuration) {\n      durationChanged = true\n      this._playableRegionDuration = newDuration\n    }\n\n    // Note the end time is not the playableRegionDuration\n    // The end time will always increase even if content is removed from the beginning\n    let endTime = fragments[0].start + newDuration\n    let previousEndTime = previousPlayableRegionStartTime + previousPlayableRegionDuration\n    let endTimeChanged = endTime !== previousEndTime\n    if (endTimeChanged) {\n      if (!this._localEndTimeCorrelation) {\n        // set the correlation to map to the end\n        this._localEndTimeCorrelation = {\n          local: this._now,\n          remote: endTime * 1000\n        }\n      } else {\n        // check if the correlation still works\n        let corr = this._localEndTimeCorrelation\n        let timePassed = this._now - corr.local\n        // this should point to a time within the extrapolation window from the end\n        let extrapolatedEndTime = (corr.remote + timePassed) / 1000\n        if (extrapolatedEndTime > endTime) {\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: endTime * 1000\n          }\n        } else if (extrapolatedEndTime < endTime - this._extrapolatedWindowDuration) {\n          // our extrapolated end time is now earlier than the extrapolation window from the actual end time\n          // (maybe a chunk became available early)\n          // reset correlation so that it sits at the beginning of the extrapolation window from the end time\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: (endTime - this._extrapolatedWindowDuration) * 1000\n          }\n        } else if (extrapolatedEndTime > previousEndTime) {\n          // end time was past the old end time (so would have been capped)\n          // set the correlation so that it resumes from the time it was at at the end of the old window\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: previousEndTime * 1000\n          }\n        }\n      }\n    }\n\n    // now that the values have been updated call any methods that use on them so they get the updated values\n    // immediately\n    durationChanged && this._onDurationChange()\n    startTimeChanged && this._onProgress()\n  }\n\n  _onFragmentChanged(evt, data) {\n    this.trigger(Events.Custom.PLAYBACK_FRAGMENT_CHANGED, data)\n  }\n\n  _onFragmentLoaded(evt, data) {\n    this.trigger(Events.PLAYBACK_FRAGMENT_LOADED, data)\n  }\n\n  _onSubtitleLoaded() {\n    // This event may be triggered multiple times\n    // Setup CC only once (disable CC by default)\n    if (!this._ccIsSetup) {\n      this.trigger(Events.PLAYBACK_SUBTITLE_AVAILABLE)\n      const trackId = this._playbackType === Playback.LIVE ? -1 : this.closedCaptionsTrackId\n      this.closedCaptionsTrackId = trackId\n      this._ccIsSetup = true\n    }\n  }\n\n  _onLevelSwitch(evt, data) {\n    if (!this.levels.length)\n      this._fillLevels()\n\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH_END)\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH, data)\n    let currentLevel = this._hls.levels[data.level]\n    if (currentLevel) {\n      // TODO should highDefinition be private and maybe have a read only accessor if it's used somewhere\n      this.highDefinition = (currentLevel.height >= 720 || (currentLevel.bitrate / 1000) >= 2000)\n      this.trigger(Events.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinition)\n      this.trigger(Events.PLAYBACK_BITRATE, {\n        height: currentLevel.height,\n        width: currentLevel.width,\n        bandwidth: currentLevel.bitrate,\n        bitrate: currentLevel.bitrate,\n        level: data.level\n      })\n    }\n  }\n\n  get dvrEnabled() {\n    // enabled when:\n    // - the duration does not include content after hlsjs's live sync point\n    // - the playable region duration is longer than the configured duration to enable dvr after\n    // - the playback type is LIVE.\n    return (this._durationExcludesAfterLiveSyncPoint && this._duration >= this._minDvrSize && this.getPlaybackType() === Playback.LIVE)\n  }\n\n  getPlaybackType() {\n    return this._playbackType\n  }\n\n  isSeekEnabled() {\n    return (this._playbackType === Playback.VOD || this.dvrEnabled)\n  }\n}\n\nHlsjsPlayback.canPlay = function(resource, mimeType) {\n  const resourceParts = resource.split('?')[0].match(/.*\\.(.*)$/) || []\n  const isHls = ((resourceParts.length > 1 && resourceParts[1].toLowerCase() === 'm3u8') || listContainsIgnoreCase(mimeType, ['application/vnd.apple.mpegurl', 'application/x-mpegURL']))\n\n  return !!(HLSJS.isSupported() && isHls)\n}\n"],"names":["now","Utils","assign","listContainsIgnoreCase","register","HlsjsPlayback","args","options","playback","_this","_minDvrSize","hlsMinimumDvrSize","_extrapolatedWindowNumSegments","extrapolatedWindowNumSegments","_playbackType","Playback","VOD","_lastTimeUpdate","current","total","_lastDuration","_playableRegionStartTime","_localStartTimeCorrelation","_localEndTimeCorrelation","_playableRegionDuration","_programDateTime","_durationExcludesAfterLiveSyncPoint","_segmentTargetDuration","_playlistType","_recoverAttemptsRemaining","hlsRecoverAttempts","min","this","_levels","_currentLevel","undefined","id","trigger","Events","PLAYBACK_LEVEL_SWITCH_START","hlsUseNextLevel","_hls","nextLevel","currentLevel","_isReadyState","LIVE","_extrapolatedStartTime","corr","timePassed","_now","local","extrapolatedWindowStartTime","remote","Math","_extrapolatedWindowDuration","actualEndTime","extrapolatedEndTime","max","_extrapolatedEndTime","_startTime","bandwidthEstimate","HLSJS","_ccIsSetup","_ccTracksUpdated","hlsjsConfig","once","MEDIA_ATTACHED","_this2","loadSource","src","on","LEVEL_LOADED","evt","data","_updatePlaybackType","LEVEL_UPDATED","_onLevelUpdated","LEVEL_SWITCHING","_onLevelSwitch","FRAG_CHANGED","_onFragmentChanged","FRAG_LOADED","_onFragmentLoaded","FRAG_PARSING_METADATA","_onFragmentParsingMetadata","ERROR","_onHLSJSError","SUBTITLE_TRACK_LOADED","_onSubtitleLoaded","SUBTITLE_TRACKS_UPDATED","attachMedia","el","Custom","PLAYBACK_FRAGMENT_PARSING_METADATA","_ready","PLAYBACK_READY","name","error","_recoveredDecodingError","_recoveredAudioCodecError","Log","level","PlayerError","Levels","FATAL","formattedError","createError","PLAYBACK_ERROR","stop","swapAudioCodec","recoverMediaError","srcUrl","_timeUpdateTimer","setInterval","_this3","_onDurationChange","_onTimeUpdate","clearInterval","_duration","currentTime","percentage","seekTo","seek","time","warn","getDuration","dvrEnabled","_updateDvr","status","PLAYBACK_DVR","PLAYBACK_STATS_ADD","settings","left","seekEnabled","isSeekEnabled","PLAYBACK_SETTINGSUPDATE","code","type","details","description","raw","response","JSON","stringify","fatal","ErrorTypes","NETWORK_ERROR","ErrorDetails","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","MANIFEST_PARSING_ERROR","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","WARN","startLoad","MEDIA_ERROR","_recover","triggerFatalErrorOnResourceDenied","_keyIsDenied","KEY_LOAD_ERROR","update","getCurrentTime","firstFragDateTime","getProgramDateTime","PLAYBACK_TIMEUPDATE","duration","buffered","length","bufferedPos","i","start","end","progress","PLAYBACK_PROGRESS","_setup","_startTimeUpdateTimer","pause","_stopTimeUpdateTimer","destroy","live","hasClosedCaptionsTracks","levels","map","index","label","bitrate","PLAYBACK_LEVELS_AVAILABLE","targetduration","startTimeChanged","durationChanged","fragments","previousPlayableRegionStartTime","previousPlayableRegionDuration","rawProgramDateTime","startTime","newDuration","totalduration","hiddenAreaDuration","liveSyncDurationCount","DefaultConfig","endTime","previousEndTime","_onProgress","PLAYBACK_FRAGMENT_CHANGED","PLAYBACK_FRAGMENT_LOADED","PLAYBACK_SUBTITLE_AVAILABLE","trackId","closedCaptionsTrackId","_fillLevels","PLAYBACK_LEVEL_SWITCH_END","PLAYBACK_LEVEL_SWITCH","highDefinition","height","PLAYBACK_HIGHDEFINITIONUPDATE","PLAYBACK_BITRATE","width","bandwidth","getPlaybackType","HTML5Video","canPlay","resource","mimeType","resourceParts","split","match","isHls","toLowerCase","isSupported"],"mappings":"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"}